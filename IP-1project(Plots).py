# -*- coding: utf-8 -*-
"""Untitled5.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19pQujbriDUvhm-HqKltZkG0g3iFgkDod
"""

!pip install basemap
!pip install cartopy
!pip install seaborn
!pip install shapely

# code for generating density plots on the basis of count and probability of observations per grid cell at Bay of Bengal from the dataset retrived from ARGO FLOATS (Only Indian)
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.basemap import Basemap
from scipy.ndimage import gaussian_filter
from scipy.interpolate import griddata

# Load the CSV file
data = pd.read_csv('Book(1).csv')

# Extract latitude and longitude columns
latitudes = data['latitude']
longitudes = data['longitude']

# Filter the data where institution is 'IN'
data_filtered = data[data['institution'] == 'IN']
latitudes = data_filtered['latitude']
longitudes = data_filtered['longitude']

# Define grid parameters
lat_min, lat_max = 7, 30
lon_min, lon_max = 77, 105
lat_bins = lat_max - lat_min
lon_bins = lon_max - lon_min

# Initialize a grid to count observations
grid = np.zeros((lat_bins, lon_bins))

# Create Basemap instance for land-sea mask
m = Basemap(projection='cyl', llcrnrlat=lat_min, urcrnrlat=lat_max, llcrnrlon=lon_min, urcrnrlon=lon_max, resolution='l')

# Generate a land-sea mask for the grid cells
mask = np.zeros((lat_bins, lon_bins))
for lat_idx in range(lat_bins):
    for lon_idx in range(lon_bins):
        lon, lat = lon_min + lon_idx, lat_min + lat_idx
        x, y = m(lon, lat)
        mask[lat_idx, lon_idx] = m.is_land(x, y)  # Check if the point is land (1) or sea (0)

# Count observations in each grid cell excluding land cells
for lat, lon in zip(latitudes, longitudes):
    lat_idx, lon_idx = int(lat - lat_min), int(lon - lon_min)
    if 0 <= lat_idx < lat_bins and 0 <= lon_idx < lon_bins and mask[lat_idx, lon_idx] == 0:
        grid[lat_idx, lon_idx] += 1

# Apply Gaussian smoothing to the grid of observations
smooth_grid = gaussian_filter(grid, sigma=2)

# Normalize the smoothed grid to get the probability density
min_obs = np.min(smooth_grid)
max_obs = np.max(smooth_grid)
normalized_smooth_grid = (smooth_grid - min_obs) / (max_obs - min_obs)

# Create finer grid for upsampling
lon_new = np.linspace(lon_min, lon_max, lon_bins * 10)
lat_new = np.linspace(lat_min, lat_max, lat_bins * 10)
lon_new, lat_new = np.meshgrid(lon_new, lat_new)

# Interpolate the smoothed grid
points = np.array([(i, j) for i in range(lat_bins) for j in range(lon_bins)])
values = smooth_grid.flatten()
smooth_grid_upsampled = griddata(points, values, (lat_new - lat_min, lon_new - lon_min), method='cubic')

# Interpolate the normalized smoothed grid for probability density
values_normalized = normalized_smooth_grid.flatten()
smooth_normalized_grid_upsampled = griddata(points, values_normalized, (lat_new - lat_min, lon_new - lon_min), method='cubic')

# Plot the smoothed number of observations per grid cell
plt.figure(figsize=(20, 10))
plt.imshow(smooth_grid_upsampled, extent=[lon_min, lon_max, lat_min, lat_max], origin='lower', cmap='jet', alpha=0.6)
m.drawcoastlines()
m.drawcountries()
m.fillcontinents(color='white', lake_color='aqua')  # Change land color to white

# Draw parallels and meridians with 1-degree intervals, label every 5 degrees
parallels = np.arange(lat_min, lat_max + 1, 1)
meridians = np.arange(lon_min, lon_max + 1, 1)
m.drawparallels(parallels, labels=[0, 0, 0, 0], fontsize=10)
m.drawmeridians(meridians, labels=[0, 0, 0, 0], fontsize=10)

# Label every 5 degrees and their multiples
m.drawparallels(np.arange(lat_min, lat_max + 1, 5), labels=[1, 0, 0, 0], fontsize=10)
m.drawmeridians(np.arange(lon_min, lon_max + 1, 5), labels=[0, 0, 0, 1], fontsize=10)

plt.colorbar(label='Number of Observations')
plt.xlabel('Longitude')
plt.ylabel('Latitude')
plt.title('Sum of Observations per Grid Cell at Bay of Bengal (Only Indian)')

plt.tight_layout()
plt.show()

# Plot the smoothed probability density plot
plt.figure(figsize=(20, 10))
plt.imshow(smooth_normalized_grid_upsampled, extent=[lon_min, lon_max, lat_min, lat_max], origin='lower', cmap='jet', alpha=0.6)
m.drawcoastlines()
m.drawcountries()
m.fillcontinents(color='white', lake_color='aqua')  # Change land color to white

# Draw parallels and meridians with 1-degree intervals, label every 5 degrees
m.drawparallels(parallels, labels=[0, 0, 0, 0], fontsize=10)
m.drawmeridians(meridians, labels=[0, 0, 0, 0], fontsize=10)

# Label every 5 degrees and their multiples
m.drawparallels(np.arange(lat_min, lat_max + 1, 5), labels=[1, 0, 0, 0], fontsize=10)
m.drawmeridians(np.arange(lon_min, lon_max + 1, 5), labels=[0, 0, 0, 1], fontsize=10)

plt.colorbar(label='Probability Density')

plt.xlabel('Longitude')
plt.ylabel('Latitude')
plt.title('Probability Density per Grid Cell at Bay of Bengal (Only Indian)')

plt.tight_layout()
plt.show()

# code for generating density plots on the basis of count and probability of observations per grid cell at Arabian Sea from the dataset retrived from ARGO FLOATS (Only Indian)
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.basemap import Basemap
from scipy.ndimage import gaussian_filter
from scipy.interpolate import griddata

# Load the CSV file
data = pd.read_csv('Book(1).csv')

# Extract latitude and longitude columns
latitudes = data['latitude']
longitudes = data['longitude']

# Filter the data where institution is 'IN'
data_filtered = data[data['institution'] == 'IN']
latitudes = data_filtered['latitude']
longitudes = data_filtered['longitude']

# Define grid parameters
lat_min, lat_max = 7, 30
lon_min, lon_max = 30, 77
lat_bins = lat_max - lat_min
lon_bins = lon_max - lon_min

# Initialize a grid to count observations
grid = np.zeros((lat_bins, lon_bins))

# Create Basemap instance for land-sea mask
m = Basemap(projection='cyl', llcrnrlat=lat_min, urcrnrlat=lat_max, llcrnrlon=lon_min, urcrnrlon=lon_max, resolution='l')

# Generate a land-sea mask for the grid cells
mask = np.zeros((lat_bins, lon_bins))
for lat_idx in range(lat_bins):
    for lon_idx in range(lon_bins):
        lon, lat = lon_min + lon_idx, lat_min + lat_idx
        x, y = m(lon, lat)
        mask[lat_idx, lon_idx] = m.is_land(x, y)  # Check if the point is land (1) or sea (0)

# Count observations in each grid cell excluding land cells
for lat, lon in zip(latitudes, longitudes):
    lat_idx, lon_idx = int(lat - lat_min), int(lon - lon_min)
    if 0 <= lat_idx < lat_bins and 0 <= lon_idx < lon_bins and mask[lat_idx, lon_idx] == 0:
        grid[lat_idx, lon_idx] += 1

# Apply Gaussian smoothing to the grid of observations
smooth_grid = gaussian_filter(grid, sigma=2)

# Normalize the smoothed grid to get the probability density
min_obs = np.min(smooth_grid)
max_obs = np.max(smooth_grid)
normalized_smooth_grid = (smooth_grid - min_obs) / (max_obs - min_obs)

# Create finer grid for upsampling
lon_new = np.linspace(lon_min, lon_max, lon_bins * 10)
lat_new = np.linspace(lat_min, lat_max, lat_bins * 10)
lon_new, lat_new = np.meshgrid(lon_new, lat_new)

# Interpolate the smoothed grid
points = np.array([(i, j) for i in range(lat_bins) for j in range(lon_bins)])
values = smooth_grid.flatten()
smooth_grid_upsampled = griddata(points, values, (lat_new - lat_min, lon_new - lon_min), method='cubic')

# Interpolate the normalized smoothed grid for probability density
values_normalized = normalized_smooth_grid.flatten()
smooth_normalized_grid_upsampled = griddata(points, values_normalized, (lat_new - lat_min, lon_new - lon_min), method='cubic')

# Plot the smoothed number of observations per grid cell
plt.figure(figsize=(20, 10))
plt.imshow(smooth_grid_upsampled, extent=[lon_min, lon_max, lat_min, lat_max], origin='lower', cmap='jet', alpha=0.6)
m.drawcoastlines()
m.drawcountries()
m.fillcontinents(color='white', lake_color='aqua')  # Change land color to white

# Draw parallels and meridians with 1-degree intervals, label every 5 degrees
parallels = np.arange(lat_min, lat_max + 1, 1)
meridians = np.arange(lon_min, lon_max + 1, 1)
m.drawparallels(parallels, labels=[0, 0, 0, 0], fontsize=10)
m.drawmeridians(meridians, labels=[0, 0, 0, 0], fontsize=10)

# Label every 5 degrees and their multiples
m.drawparallels(np.arange(lat_min, lat_max + 1, 5), labels=[1, 0, 0, 0], fontsize=10)
m.drawmeridians(np.arange(lon_min, lon_max + 1, 5), labels=[0, 0, 0, 1], fontsize=10)

plt.colorbar(label='Number of Observations')
plt.xlabel('Longitude')
plt.ylabel('Latitude')
plt.title('Sum of Observations per Grid Cell at Arabian Sea (Only Indian)')

plt.tight_layout()
plt.show()

# Plot the smoothed probability density plot
plt.figure(figsize=(20, 10))
plt.imshow(smooth_normalized_grid_upsampled, extent=[lon_min, lon_max, lat_min, lat_max], origin='lower', cmap='jet', alpha=0.6)
m.drawcoastlines()
m.drawcountries()
m.fillcontinents(color='white', lake_color='aqua')  # Change land color to white

# Draw parallels and meridians with 1-degree intervals, label every 5 degrees
m.drawparallels(parallels, labels=[0, 0, 0, 0], fontsize=10)
m.drawmeridians(meridians, labels=[0, 0, 0, 0], fontsize=10)

# Label every 5 degrees and their multiples
m.drawparallels(np.arange(lat_min, lat_max + 1, 5), labels=[1, 0, 0, 0], fontsize=10)
m.drawmeridians(np.arange(lon_min, lon_max + 1, 5), labels=[0, 0, 0, 1], fontsize=10)

plt.colorbar(label='Probability Density')

plt.xlabel('Longitude')
plt.ylabel('Latitude')
plt.title('Probability Density per Grid Cell at Arabian Sea (Only Indian)')

plt.tight_layout()
plt.show()

# code for generating density plots on the basis of count and probability of observations per grid cell at Southern Indian Ocean from the dataset retrived from ARGO FLOATS (Only Indian)
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.basemap import Basemap
from scipy.ndimage import gaussian_filter
from scipy.interpolate import griddata

# Load the CSV file
data = pd.read_csv('Book(1).csv')

# Extract latitude and longitude columns
latitudes = data['latitude']
longitudes = data['longitude']

# Filter the data where institution is 'IN'
data_filtered = data[data['institution'] == 'IN']
latitudes = data_filtered['latitude']
longitudes = data_filtered['longitude']

# Define grid parameters
lat_min, lat_max = -30, 7
lon_min, lon_max = 30, 120
lat_bins = lat_max - lat_min
lon_bins = lon_max - lon_min

# Initialize a grid to count observations
grid = np.zeros((lat_bins, lon_bins))

# Create Basemap instance for land-sea mask
m = Basemap(projection='cyl', llcrnrlat=lat_min, urcrnrlat=lat_max, llcrnrlon=lon_min, urcrnrlon=lon_max, resolution='l')

# Generate a land-sea mask for the grid cells
mask = np.zeros((lat_bins, lon_bins))
for lat_idx in range(lat_bins):
    for lon_idx in range(lon_bins):
        lon, lat = lon_min + lon_idx, lat_min + lat_idx
        x, y = m(lon, lat)
        mask[lat_idx, lon_idx] = m.is_land(x, y)  # Check if the point is land (1) or sea (0)

# Count observations in each grid cell excluding land cells
for lat, lon in zip(latitudes, longitudes):
    lat_idx, lon_idx = int(lat - lat_min), int(lon - lon_min)
    if 0 <= lat_idx < lat_bins and 0 <= lon_idx < lon_bins and mask[lat_idx, lon_idx] == 0:
        grid[lat_idx, lon_idx] += 1

# Apply Gaussian smoothing to the grid of observations
smooth_grid = gaussian_filter(grid, sigma=2)

# Normalize the smoothed grid to get the probability density
min_obs = np.min(smooth_grid)
max_obs = np.max(smooth_grid)
normalized_smooth_grid = (smooth_grid - min_obs) / (max_obs - min_obs)

# Create finer grid for upsampling
lon_new = np.linspace(lon_min, lon_max, lon_bins * 10)
lat_new = np.linspace(lat_min, lat_max, lat_bins * 10)
lon_new, lat_new = np.meshgrid(lon_new, lat_new)

# Interpolate the smoothed grid
points = np.array([(i, j) for i in range(lat_bins) for j in range(lon_bins)])
values = smooth_grid.flatten()
smooth_grid_upsampled = griddata(points, values, (lat_new - lat_min, lon_new - lon_min), method='cubic')

# Interpolate the normalized smoothed grid for probability density
values_normalized = normalized_smooth_grid.flatten()
smooth_normalized_grid_upsampled = griddata(points, values_normalized, (lat_new - lat_min, lon_new - lon_min), method='cubic')

# Plot the smoothed number of observations per grid cell
plt.figure(figsize=(20, 10))
plt.imshow(smooth_grid_upsampled, extent=[lon_min, lon_max, lat_min, lat_max], origin='lower', cmap='jet', alpha=0.6)
m.drawcoastlines()
m.drawcountries()
m.fillcontinents(color='white', lake_color='aqua')  # Change land color to white

# Draw parallels and meridians with 1-degree intervals, label every 5 degrees
parallels = np.arange(lat_min, lat_max + 1, 1)
meridians = np.arange(lon_min, lon_max + 1, 1)
m.drawparallels(parallels, labels=[0, 0, 0, 0], fontsize=10)
m.drawmeridians(meridians, labels=[0, 0, 0, 0], fontsize=10)

# Label every 5 degrees and their multiples
m.drawparallels(np.arange(lat_min, lat_max + 1, 5), labels=[1, 0, 0, 0], fontsize=10)
m.drawmeridians(np.arange(lon_min, lon_max + 1, 5), labels=[0, 0, 0, 1], fontsize=10)

plt.colorbar(label='Number of Observations')
plt.xlabel('Longitude')
plt.ylabel('Latitude')
plt.title('Sum of Observations per Grid Cell at Southern Indian Ocean (Only Indian)')

plt.tight_layout()
plt.show()

# Plot the smoothed probability density plot
plt.figure(figsize=(20, 10))
plt.imshow(smooth_normalized_grid_upsampled, extent=[lon_min, lon_max, lat_min, lat_max], origin='lower', cmap='jet', alpha=0.6)
m.drawcoastlines()
m.drawcountries()
m.fillcontinents(color='white', lake_color='aqua')  # Change land color to white

# Draw parallels and meridians with 1-degree intervals, label every 5 degrees
m.drawparallels(parallels, labels=[0, 0, 0, 0], fontsize=10)
m.drawmeridians(meridians, labels=[0, 0, 0, 0], fontsize=10)

# Label every 5 degrees and their multiples
m.drawparallels(np.arange(lat_min, lat_max + 1, 5), labels=[1, 0, 0, 0], fontsize=10)
m.drawmeridians(np.arange(lon_min, lon_max + 1, 5), labels=[0, 0, 0, 1], fontsize=10)

plt.colorbar(label='Probability Density')

plt.xlabel('Longitude')
plt.ylabel('Latitude')
plt.title('Probability Density per Grid Cell at Southern Indian Ocean (Only Indian)')

plt.tight_layout()
plt.show()

# code for generating density plots on the basis of count and probability of observations per grid cell at Bay of Bengal from the dataset retrived from ARGO FLOATS (Other Countries)
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.basemap import Basemap
from scipy.ndimage import gaussian_filter
from scipy.interpolate import griddata

# Load the CSV file
data = pd.read_csv('Book(1).csv')

# Extract latitude and longitude columns
latitudes = data['latitude']
longitudes = data['longitude']

# Filter the data where institution is 'IN'
data_filtered = data[data['institution'] != 'IN']
latitudes = data_filtered['latitude']
longitudes = data_filtered['longitude']

# Define grid parameters
lat_min, lat_max = 7, 30
lon_min, lon_max = 77, 105
lat_bins = lat_max - lat_min
lon_bins = lon_max - lon_min

# Initialize a grid to count observations
grid = np.zeros((lat_bins, lon_bins))

# Create Basemap instance for land-sea mask
m = Basemap(projection='cyl', llcrnrlat=lat_min, urcrnrlat=lat_max, llcrnrlon=lon_min, urcrnrlon=lon_max, resolution='l')

# Generate a land-sea mask for the grid cells
mask = np.zeros((lat_bins, lon_bins))
for lat_idx in range(lat_bins):
    for lon_idx in range(lon_bins):
        lon, lat = lon_min + lon_idx, lat_min + lat_idx
        x, y = m(lon, lat)
        mask[lat_idx, lon_idx] = m.is_land(x, y)  # Check if the point is land (1) or sea (0)

# Count observations in each grid cell excluding land cells
for lat, lon in zip(latitudes, longitudes):
    lat_idx, lon_idx = int(lat - lat_min), int(lon - lon_min)
    if 0 <= lat_idx < lat_bins and 0 <= lon_idx < lon_bins and mask[lat_idx, lon_idx] == 0:
        grid[lat_idx, lon_idx] += 1

# Apply Gaussian smoothing to the grid of observations
smooth_grid = gaussian_filter(grid, sigma=2)

# Normalize the smoothed grid to get the probability density
min_obs = np.min(smooth_grid)
max_obs = np.max(smooth_grid)
normalized_smooth_grid = (smooth_grid - min_obs) / (max_obs - min_obs)

# Create finer grid for upsampling
lon_new = np.linspace(lon_min, lon_max, lon_bins * 10)
lat_new = np.linspace(lat_min, lat_max, lat_bins * 10)
lon_new, lat_new = np.meshgrid(lon_new, lat_new)

# Interpolate the smoothed grid
points = np.array([(i, j) for i in range(lat_bins) for j in range(lon_bins)])
values = smooth_grid.flatten()
smooth_grid_upsampled = griddata(points, values, (lat_new - lat_min, lon_new - lon_min), method='cubic')

# Interpolate the normalized smoothed grid for probability density
values_normalized = normalized_smooth_grid.flatten()
smooth_normalized_grid_upsampled = griddata(points, values_normalized, (lat_new - lat_min, lon_new - lon_min), method='cubic')

# Plot the smoothed number of observations per grid cell
plt.figure(figsize=(20, 10))
plt.imshow(smooth_grid_upsampled, extent=[lon_min, lon_max, lat_min, lat_max], origin='lower', cmap='jet', alpha=0.6)
m.drawcoastlines()
m.drawcountries()
m.fillcontinents(color='white', lake_color='aqua')  # Change land color to white

# Draw parallels and meridians with 1-degree intervals, label every 5 degrees
parallels = np.arange(lat_min, lat_max + 1, 1)
meridians = np.arange(lon_min, lon_max + 1, 1)
m.drawparallels(parallels, labels=[0, 0, 0, 0], fontsize=10)
m.drawmeridians(meridians, labels=[0, 0, 0, 0], fontsize=10)

# Label every 5 degrees and their multiples
m.drawparallels(np.arange(lat_min, lat_max + 1, 5), labels=[1, 0, 0, 0], fontsize=10)
m.drawmeridians(np.arange(lon_min, lon_max + 1, 5), labels=[0, 0, 0, 1], fontsize=10)

plt.colorbar(label='Number of Observations')
plt.xlabel('Longitude')
plt.ylabel('Latitude')
plt.title('Sum of Observations per Grid Cell at Bay Of Bengal (Other Countries)')

plt.tight_layout()
plt.show()

# Plot the smoothed probability density plot
plt.figure(figsize=(20, 10))
plt.imshow(smooth_normalized_grid_upsampled, extent=[lon_min, lon_max, lat_min, lat_max], origin='lower', cmap='jet', alpha=0.6)
m.drawcoastlines()
m.drawcountries()
m.fillcontinents(color='white', lake_color='aqua')  # Change land color to white

# Draw parallels and meridians with 1-degree intervals, label every 5 degrees
m.drawparallels(parallels, labels=[0, 0, 0, 0], fontsize=10)
m.drawmeridians(meridians, labels=[0, 0, 0, 0], fontsize=10)

# Label every 5 degrees and their multiples
m.drawparallels(np.arange(lat_min, lat_max + 1, 5), labels=[1, 0, 0, 0], fontsize=10)
m.drawmeridians(np.arange(lon_min, lon_max + 1, 5), labels=[0, 0, 0, 1], fontsize=10)

plt.colorbar(label='Probability Density')

plt.xlabel('Longitude')
plt.ylabel('Latitude')
plt.title('Probability Density per Grid Cell at Bay of Bengal (Other Countries)')

plt.tight_layout()
plt.show()

# code for generating density plots on the basis of count and probability of observations per grid cell at Arabian Sea from the dataset retrived from ARGO FLOATS (Other Countries)
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.basemap import Basemap
from scipy.ndimage import gaussian_filter
from scipy.interpolate import griddata

# Load the CSV file
data = pd.read_csv('Book(1).csv')

# Extract latitude and longitude columns
latitudes = data['latitude']
longitudes = data['longitude']

# Filter the data where institution is 'IN'
data_filtered = data[data['institution'] != 'IN']
latitudes = data_filtered['latitude']
longitudes = data_filtered['longitude']

# Define grid parameters
lat_min, lat_max = 7, 30
lon_min, lon_max = 30, 79
lat_bins = lat_max - lat_min
lon_bins = lon_max - lon_min

# Initialize a grid to count observations
grid = np.zeros((lat_bins, lon_bins))

# Create Basemap instance for land-sea mask
m = Basemap(projection='cyl', llcrnrlat=lat_min, urcrnrlat=lat_max, llcrnrlon=lon_min, urcrnrlon=lon_max, resolution='l')

# Generate a land-sea mask for the grid cells
mask = np.zeros((lat_bins, lon_bins))
for lat_idx in range(lat_bins):
    for lon_idx in range(lon_bins):
        lon, lat = lon_min + lon_idx, lat_min + lat_idx
        x, y = m(lon, lat)
        mask[lat_idx, lon_idx] = m.is_land(x, y)  # Check if the point is land (1) or sea (0)

# Count observations in each grid cell excluding land cells
for lat, lon in zip(latitudes, longitudes):
    lat_idx, lon_idx = int(lat - lat_min), int(lon - lon_min)
    if 0 <= lat_idx < lat_bins and 0 <= lon_idx < lon_bins and mask[lat_idx, lon_idx] == 0:
        grid[lat_idx, lon_idx] += 1

# Apply Gaussian smoothing to the grid of observations
smooth_grid = gaussian_filter(grid, sigma=2)

# Normalize the smoothed grid to get the probability density
min_obs = np.min(smooth_grid)
max_obs = np.max(smooth_grid)
normalized_smooth_grid = (smooth_grid - min_obs) / (max_obs - min_obs)

# Create finer grid for upsampling
lon_new = np.linspace(lon_min, lon_max, lon_bins * 10)
lat_new = np.linspace(lat_min, lat_max, lat_bins * 10)
lon_new, lat_new = np.meshgrid(lon_new, lat_new)

# Interpolate the smoothed grid
points = np.array([(i, j) for i in range(lat_bins) for j in range(lon_bins)])
values = smooth_grid.flatten()
smooth_grid_upsampled = griddata(points, values, (lat_new - lat_min, lon_new - lon_min), method='cubic')

# Interpolate the normalized smoothed grid for probability density
values_normalized = normalized_smooth_grid.flatten()
smooth_normalized_grid_upsampled = griddata(points, values_normalized, (lat_new - lat_min, lon_new - lon_min), method='cubic')

# Plot the smoothed number of observations per grid cell
plt.figure(figsize=(20, 10))
plt.imshow(smooth_grid_upsampled, extent=[lon_min, lon_max, lat_min, lat_max], origin='lower', cmap='jet', alpha=0.6)
m.drawcoastlines()
m.drawcountries()
m.fillcontinents(color='white', lake_color='aqua')  # Change land color to white

# Draw parallels and meridians with 1-degree intervals, label every 5 degrees
parallels = np.arange(lat_min, lat_max + 1, 1)
meridians = np.arange(lon_min, lon_max + 1, 1)
m.drawparallels(parallels, labels=[0, 0, 0, 0], fontsize=10)
m.drawmeridians(meridians, labels=[0, 0, 0, 0], fontsize=10)

# Label every 5 degrees and their multiples
m.drawparallels(np.arange(lat_min, lat_max + 1, 5), labels=[1, 0, 0, 0], fontsize=10)
m.drawmeridians(np.arange(lon_min, lon_max + 1, 5), labels=[0, 0, 0, 1], fontsize=10)

plt.colorbar(label='Number of Observations')
plt.xlabel('Longitude')
plt.ylabel('Latitude')
plt.title('Sum of Observations per Grid Cell at Arabian Sea (Other Countries)')

plt.tight_layout()
plt.show()

# Plot the smoothed probability density plot
plt.figure(figsize=(20, 10))
plt.imshow(smooth_normalized_grid_upsampled, extent=[lon_min, lon_max, lat_min, lat_max], origin='lower', cmap='jet', alpha=0.6)
m.drawcoastlines()
m.drawcountries()
m.fillcontinents(color='white', lake_color='aqua')  # Change land color to white

# Draw parallels and meridians with 1-degree intervals, label every 5 degrees
m.drawparallels(parallels, labels=[0, 0, 0, 0], fontsize=10)
m.drawmeridians(meridians, labels=[0, 0, 0, 0], fontsize=10)

# Label every 5 degrees and their multiples
m.drawparallels(np.arange(lat_min, lat_max + 1, 5), labels=[1, 0, 0, 0], fontsize=10)
m.drawmeridians(np.arange(lon_min, lon_max + 1, 5), labels=[0, 0, 0, 1], fontsize=10)

plt.colorbar(label='Probability Density')

plt.xlabel('Longitude')
plt.ylabel('Latitude')
plt.title('Probability Density per Grid Cell at Arabian Sea (Other Countries)')

plt.tight_layout()
plt.show()

# code for generating density plots on the basis of count and probability of observations per grid cell at Southern Indian Ocean from the dataset retrived from ARGO FLOATS (Other Countries)
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.basemap import Basemap
from scipy.ndimage import gaussian_filter
from scipy.interpolate import griddata

# Load the CSV file
data = pd.read_csv('Book(1).csv')

# Extract latitude and longitude columns
latitudes = data['latitude']
longitudes = data['longitude']

# Filter the data where institution is 'IN'
data_filtered = data[data['institution'] != 'IN']
latitudes = data_filtered['latitude']
longitudes = data_filtered['longitude']

# Define grid parameters
lat_min, lat_max = -30, 7
lon_min, lon_max = 30, 120
lat_bins = lat_max - lat_min
lon_bins = lon_max - lon_min

# Initialize a grid to count observations
grid = np.zeros((lat_bins, lon_bins))

# Create Basemap instance for land-sea mask
m = Basemap(projection='cyl', llcrnrlat=lat_min, urcrnrlat=lat_max, llcrnrlon=lon_min, urcrnrlon=lon_max, resolution='l')

# Generate a land-sea mask for the grid cells
mask = np.zeros((lat_bins, lon_bins))
for lat_idx in range(lat_bins):
    for lon_idx in range(lon_bins):
        lon, lat = lon_min + lon_idx, lat_min + lat_idx
        x, y = m(lon, lat)
        mask[lat_idx, lon_idx] = m.is_land(x, y)  # Check if the point is land (1) or sea (0)

# Count observations in each grid cell excluding land cells
for lat, lon in zip(latitudes, longitudes):
    lat_idx, lon_idx = int(lat - lat_min), int(lon - lon_min)
    if 0 <= lat_idx < lat_bins and 0 <= lon_idx < lon_bins and mask[lat_idx, lon_idx] == 0:
        grid[lat_idx, lon_idx] += 1

# Apply Gaussian smoothing to the grid of observations
smooth_grid = gaussian_filter(grid, sigma=2)

# Normalize the smoothed grid to get the probability density
min_obs = np.min(smooth_grid)
max_obs = np.max(smooth_grid)
normalized_smooth_grid = (smooth_grid - min_obs) / (max_obs - min_obs)

# Create finer grid for upsampling
lon_new = np.linspace(lon_min, lon_max, lon_bins * 10)
lat_new = np.linspace(lat_min, lat_max, lat_bins * 10)
lon_new, lat_new = np.meshgrid(lon_new, lat_new)

# Interpolate the smoothed grid
points = np.array([(i, j) for i in range(lat_bins) for j in range(lon_bins)])
values = smooth_grid.flatten()
smooth_grid_upsampled = griddata(points, values, (lat_new - lat_min, lon_new - lon_min), method='cubic')

# Interpolate the normalized smoothed grid for probability density
values_normalized = normalized_smooth_grid.flatten()
smooth_normalized_grid_upsampled = griddata(points, values_normalized, (lat_new - lat_min, lon_new - lon_min), method='cubic')

# Plot the smoothed number of observations per grid cell
plt.figure(figsize=(20, 10))
plt.imshow(smooth_grid_upsampled, extent=[lon_min, lon_max, lat_min, lat_max], origin='lower', cmap='jet', alpha=0.6)
m.drawcoastlines()
m.drawcountries()
m.fillcontinents(color='white', lake_color='aqua')  # Change land color to white

# Draw parallels and meridians with 1-degree intervals, label every 5 degrees
parallels = np.arange(lat_min, lat_max + 1, 1)
meridians = np.arange(lon_min, lon_max + 1, 1)
m.drawparallels(parallels, labels=[0, 0, 0, 0], fontsize=10)
m.drawmeridians(meridians, labels=[0, 0, 0, 0], fontsize=10)

# Label every 5 degrees and their multiples
m.drawparallels(np.arange(lat_min, lat_max + 1, 5), labels=[1, 0, 0, 0], fontsize=10)
m.drawmeridians(np.arange(lon_min, lon_max + 1, 5), labels=[0, 0, 0, 1], fontsize=10)

plt.colorbar(label='Number of Observations')
plt.xlabel('Longitude')
plt.ylabel('Latitude')
plt.title('Sum of Observations per Grid Cell at Southern Indian Ocean (Other Countries)')

plt.tight_layout()
plt.show()

# Plot the smoothed probability density plot
plt.figure(figsize=(20, 10))
plt.imshow(smooth_normalized_grid_upsampled, extent=[lon_min, lon_max, lat_min, lat_max], origin='lower', cmap='jet', alpha=0.6)
m.drawcoastlines()
m.drawcountries()
m.fillcontinents(color='white', lake_color='aqua')  # Change land color to white

# Draw parallels and meridians with 1-degree intervals, label every 5 degrees
m.drawparallels(parallels, labels=[0, 0, 0, 0], fontsize=10)
m.drawmeridians(meridians, labels=[0, 0, 0, 0], fontsize=10)

# Label every 5 degrees and their multiples
m.drawparallels(np.arange(lat_min, lat_max + 1, 5), labels=[1, 0, 0, 0], fontsize=10)
m.drawmeridians(np.arange(lon_min, lon_max + 1, 5), labels=[0, 0, 0, 1], fontsize=10)

plt.colorbar(label='Probability Density')

plt.xlabel('Longitude')
plt.ylabel('Latitude')
plt.title('Probability Density per Grid Cell at Southern Indian Ocean (Other Countries)')

plt.tight_layout()
plt.show()

# code for generating density plots on the basis of count and probability of observations per grid cell at Bay of Bengal from the dataset retrived from ARGO FLOATS (Overall Countries)
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.basemap import Basemap
from scipy.ndimage import gaussian_filter
from scipy.interpolate import griddata

# Load the CSV file
data = pd.read_csv('Book(1).csv')

# Extract latitude and longitude columns
latitudes = data['latitude']
longitudes = data['longitude']

# Filter the data where institution is 'IN'
latitudes = data['latitude']
longitudes = data['longitude']

# Define grid parameters
lat_min, lat_max = 7, 30
lon_min, lon_max = 77, 105
lat_bins = lat_max - lat_min
lon_bins = lon_max - lon_min

# Initialize a grid to count observations
grid = np.zeros((lat_bins, lon_bins))

# Create Basemap instance for land-sea mask
m = Basemap(projection='cyl', llcrnrlat=lat_min, urcrnrlat=lat_max, llcrnrlon=lon_min, urcrnrlon=lon_max, resolution='l')

# Generate a land-sea mask for the grid cells
mask = np.zeros((lat_bins, lon_bins))
for lat_idx in range(lat_bins):
    for lon_idx in range(lon_bins):
        lon, lat = lon_min + lon_idx, lat_min + lat_idx
        x, y = m(lon, lat)
        mask[lat_idx, lon_idx] = m.is_land(x, y)  # Check if the point is land (1) or sea (0)

# Count observations in each grid cell excluding land cells
for lat, lon in zip(latitudes, longitudes):
    lat_idx, lon_idx = int(lat - lat_min), int(lon - lon_min)
    if 0 <= lat_idx < lat_bins and 0 <= lon_idx < lon_bins and mask[lat_idx, lon_idx] == 0:
        grid[lat_idx, lon_idx] += 1

# Apply Gaussian smoothing to the grid of observations
smooth_grid = gaussian_filter(grid, sigma=2)

# Normalize the smoothed grid to get the probability density
min_obs = np.min(smooth_grid)
max_obs = np.max(smooth_grid)
normalized_smooth_grid = (smooth_grid - min_obs) / (max_obs - min_obs)

# Create finer grid for upsampling
lon_new = np.linspace(lon_min, lon_max, lon_bins * 10)
lat_new = np.linspace(lat_min, lat_max, lat_bins * 10)
lon_new, lat_new = np.meshgrid(lon_new, lat_new)

# Interpolate the smoothed grid
points = np.array([(i, j) for i in range(lat_bins) for j in range(lon_bins)])
values = smooth_grid.flatten()
smooth_grid_upsampled = griddata(points, values, (lat_new - lat_min, lon_new - lon_min), method='cubic')

# Interpolate the normalized smoothed grid for probability density
values_normalized = normalized_smooth_grid.flatten()
smooth_normalized_grid_upsampled = griddata(points, values_normalized, (lat_new - lat_min, lon_new - lon_min), method='cubic')

# Plot the smoothed number of observations per grid cell
plt.figure(figsize=(20, 10))
plt.imshow(smooth_grid_upsampled, extent=[lon_min, lon_max, lat_min, lat_max], origin='lower', cmap='jet', alpha=0.6)
m.drawcoastlines()
m.drawcountries()
m.fillcontinents(color='white', lake_color='aqua')  # Change land color to white

# Draw parallels and meridians with 1-degree intervals, label every 5 degrees
parallels = np.arange(lat_min, lat_max + 1, 1)
meridians = np.arange(lon_min, lon_max + 1, 1)
m.drawparallels(parallels, labels=[0, 0, 0, 0], fontsize=10)
m.drawmeridians(meridians, labels=[0, 0, 0, 0], fontsize=10)

# Label every 5 degrees and their multiples
m.drawparallels(np.arange(lat_min, lat_max + 1, 5), labels=[1, 0, 0, 0], fontsize=10)
m.drawmeridians(np.arange(lon_min, lon_max + 1, 5), labels=[0, 0, 0, 1], fontsize=10)

plt.colorbar(label='Number of Observations')
plt.xlabel('Longitude')
plt.ylabel('Latitude')
plt.title('Sum of Observations per Grid Cell at Bay Of Bengal (Overall Countries)')

plt.tight_layout()
plt.show()

# Plot the smoothed probability density plot
plt.figure(figsize=(20, 10))
plt.imshow(smooth_normalized_grid_upsampled, extent=[lon_min, lon_max, lat_min, lat_max], origin='lower', cmap='jet', alpha=0.6)
m.drawcoastlines()
m.drawcountries()
m.fillcontinents(color='white', lake_color='aqua')  # Change land color to white

# Draw parallels and meridians with 1-degree intervals, label every 5 degrees
m.drawparallels(parallels, labels=[0, 0, 0, 0], fontsize=10)
m.drawmeridians(meridians, labels=[0, 0, 0, 0], fontsize=10)

# Label every 5 degrees and their multiples
m.drawparallels(np.arange(lat_min, lat_max + 1, 5), labels=[1, 0, 0, 0], fontsize=10)
m.drawmeridians(np.arange(lon_min, lon_max + 1, 5), labels=[0, 0, 0, 1], fontsize=10)

plt.colorbar(label='Probability Density')

plt.xlabel('Longitude')
plt.ylabel('Latitude')
plt.title('Probability Density per Grid Cell at Bay of Bengal (Overall Countries)')

plt.tight_layout()
plt.show()

# code for generating density plots on the basis of count and probability of observations per grid cell at Arabian Sea from the dataset retrived from ARGO FLOATS (Overall Countries)
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.basemap import Basemap
from scipy.ndimage import gaussian_filter
from scipy.interpolate import griddata

# Load the CSV file
data = pd.read_csv('Book(1).csv')

# Extract latitude and longitude columns
latitudes = data['latitude']
longitudes = data['longitude']

# Filter the data where institution is 'IN'
latitudes = data['latitude']
longitudes = data['longitude']

# Define grid parameters
lat_min, lat_max = 7, 30
lon_min, lon_max = 30, 77
lat_bins = lat_max - lat_min
lon_bins = lon_max - lon_min

# Initialize a grid to count observations
grid = np.zeros((lat_bins, lon_bins))

# Create Basemap instance for land-sea mask
m = Basemap(projection='cyl', llcrnrlat=lat_min, urcrnrlat=lat_max, llcrnrlon=lon_min, urcrnrlon=lon_max, resolution='l')

# Generate a land-sea mask for the grid cells
mask = np.zeros((lat_bins, lon_bins))
for lat_idx in range(lat_bins):
    for lon_idx in range(lon_bins):
        lon, lat = lon_min + lon_idx, lat_min + lat_idx
        x, y = m(lon, lat)
        mask[lat_idx, lon_idx] = m.is_land(x, y)  # Check if the point is land (1) or sea (0)

# Count observations in each grid cell excluding land cells
for lat, lon in zip(latitudes, longitudes):
    lat_idx, lon_idx = int(lat - lat_min), int(lon - lon_min)
    if 0 <= lat_idx < lat_bins and 0 <= lon_idx < lon_bins and mask[lat_idx, lon_idx] == 0:
        grid[lat_idx, lon_idx] += 1

# Apply Gaussian smoothing to the grid of observations
smooth_grid = gaussian_filter(grid, sigma=2)

# Normalize the smoothed grid to get the probability density
min_obs = np.min(smooth_grid)
max_obs = np.max(smooth_grid)
normalized_smooth_grid = (smooth_grid - min_obs) / (max_obs - min_obs)

# Create finer grid for upsampling
lon_new = np.linspace(lon_min, lon_max, lon_bins * 10)
lat_new = np.linspace(lat_min, lat_max, lat_bins * 10)
lon_new, lat_new = np.meshgrid(lon_new, lat_new)

# Interpolate the smoothed grid
points = np.array([(i, j) for i in range(lat_bins) for j in range(lon_bins)])
values = smooth_grid.flatten()
smooth_grid_upsampled = griddata(points, values, (lat_new - lat_min, lon_new - lon_min), method='cubic')

# Interpolate the normalized smoothed grid for probability density
values_normalized = normalized_smooth_grid.flatten()
smooth_normalized_grid_upsampled = griddata(points, values_normalized, (lat_new - lat_min, lon_new - lon_min), method='cubic')

# Plot the smoothed number of observations per grid cell
plt.figure(figsize=(20, 10))
plt.imshow(smooth_grid_upsampled, extent=[lon_min, lon_max, lat_min, lat_max], origin='lower', cmap='jet', alpha=0.6)
m.drawcoastlines()
m.drawcountries()
m.fillcontinents(color='white', lake_color='aqua')  # Change land color to white

# Draw parallels and meridians with 1-degree intervals, label every 5 degrees
parallels = np.arange(lat_min, lat_max + 1, 1)
meridians = np.arange(lon_min, lon_max + 1, 1)
m.drawparallels(parallels, labels=[0, 0, 0, 0], fontsize=10)
m.drawmeridians(meridians, labels=[0, 0, 0, 0], fontsize=10)

# Label every 5 degrees and their multiples
m.drawparallels(np.arange(lat_min, lat_max + 1, 5), labels=[1, 0, 0, 0], fontsize=10)
m.drawmeridians(np.arange(lon_min, lon_max + 1, 5), labels=[0, 0, 0, 1], fontsize=10)

plt.colorbar(label='Number of Observations')
plt.xlabel('Longitude')
plt.ylabel('Latitude')
plt.title('Sum of Observations per Grid Cell at Arabian Sea (Overall Countries)')

plt.tight_layout()
plt.show()

# Plot the smoothed probability density plot
plt.figure(figsize=(20, 10))
plt.imshow(smooth_normalized_grid_upsampled, extent=[lon_min, lon_max, lat_min, lat_max], origin='lower', cmap='jet', alpha=0.6)
m.drawcoastlines()
m.drawcountries()
m.fillcontinents(color='white', lake_color='aqua')  # Change land color to white

# Draw parallels and meridians with 1-degree intervals, label every 5 degrees
m.drawparallels(parallels, labels=[0, 0, 0, 0], fontsize=10)
m.drawmeridians(meridians, labels=[0, 0, 0, 0], fontsize=10)

# Label every 5 degrees and their multiples
m.drawparallels(np.arange(lat_min, lat_max + 1, 5), labels=[1, 0, 0, 0], fontsize=10)
m.drawmeridians(np.arange(lon_min, lon_max + 1, 5), labels=[0, 0, 0, 1], fontsize=10)

plt.colorbar(label='Probability Density')

plt.xlabel('Longitude')
plt.ylabel('Latitude')
plt.title('Probability Density per Grid Cell at Arabian Sea (Overall Countries)')

plt.tight_layout()
plt.show()

# code for generating density plots on the basis of count and probability of observations per grid cell at Southern Indian Ocean from the dataset retrived from ARGO FLOATS (Overall Countries)
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.basemap import Basemap
from scipy.ndimage import gaussian_filter
from scipy.interpolate import griddata

# Load the CSV file
data = pd.read_csv('Book(1).csv')

# Extract latitude and longitude columns
latitudes = data['latitude']
longitudes = data['longitude']

# Filter the data where institution is 'IN'
latitudes = data['latitude']
longitudes = data['longitude']

# Define grid parameters
lat_min, lat_max = -30, 7
lon_min, lon_max = 30, 120
lat_bins = lat_max - lat_min
lon_bins = lon_max - lon_min

# Initialize a grid to count observations
grid = np.zeros((lat_bins, lon_bins))

# Create Basemap instance for land-sea mask
m = Basemap(projection='cyl', llcrnrlat=lat_min, urcrnrlat=lat_max, llcrnrlon=lon_min, urcrnrlon=lon_max, resolution='l')

# Generate a land-sea mask for the grid cells
mask = np.zeros((lat_bins, lon_bins))
for lat_idx in range(lat_bins):
    for lon_idx in range(lon_bins):
        lon, lat = lon_min + lon_idx, lat_min + lat_idx
        x, y = m(lon, lat)
        mask[lat_idx, lon_idx] = m.is_land(x, y)  # Check if the point is land (1) or sea (0)

# Count observations in each grid cell excluding land cells
for lat, lon in zip(latitudes, longitudes):
    lat_idx, lon_idx = int(lat - lat_min), int(lon - lon_min)
    if 0 <= lat_idx < lat_bins and 0 <= lon_idx < lon_bins and mask[lat_idx, lon_idx] == 0:
        grid[lat_idx, lon_idx] += 1

# Apply Gaussian smoothing to the grid of observations
smooth_grid = gaussian_filter(grid, sigma=2)

# Normalize the smoothed grid to get the probability density
min_obs = np.min(smooth_grid)
max_obs = np.max(smooth_grid)
normalized_smooth_grid = (smooth_grid - min_obs) / (max_obs - min_obs)

# Create finer grid for upsampling
lon_new = np.linspace(lon_min, lon_max, lon_bins * 10)
lat_new = np.linspace(lat_min, lat_max, lat_bins * 10)
lon_new, lat_new = np.meshgrid(lon_new, lat_new)

# Interpolate the smoothed grid
points = np.array([(i, j) for i in range(lat_bins) for j in range(lon_bins)])
values = smooth_grid.flatten()
smooth_grid_upsampled = griddata(points, values, (lat_new - lat_min, lon_new - lon_min), method='cubic')

# Interpolate the normalized smoothed grid for probability density
values_normalized = normalized_smooth_grid.flatten()
smooth_normalized_grid_upsampled = griddata(points, values_normalized, (lat_new - lat_min, lon_new - lon_min), method='cubic')

# Plot the smoothed number of observations per grid cell
plt.figure(figsize=(20, 10))
plt.imshow(smooth_grid_upsampled, extent=[lon_min, lon_max, lat_min, lat_max], origin='lower', cmap='jet', alpha=0.6)
m.drawcoastlines()
m.drawcountries()
m.fillcontinents(color='white', lake_color='aqua')  # Change land color to white

# Draw parallels and meridians with 1-degree intervals, label every 5 degrees
parallels = np.arange(lat_min, lat_max + 1, 1)
meridians = np.arange(lon_min, lon_max + 1, 1)
m.drawparallels(parallels, labels=[0, 0, 0, 0], fontsize=10)
m.drawmeridians(meridians, labels=[0, 0, 0, 0], fontsize=10)

# Label every 5 degrees and their multiples
m.drawparallels(np.arange(lat_min, lat_max + 1, 5), labels=[1, 0, 0, 0], fontsize=10)
m.drawmeridians(np.arange(lon_min, lon_max + 1, 5), labels=[0, 0, 0, 1], fontsize=10)

plt.colorbar(label='Number of Observations')
plt.xlabel('Longitude')
plt.ylabel('Latitude')
plt.title('Sum of Observations per Grid Cell at Southern Indian Ocean (Overall Countries)')

plt.tight_layout()
plt.show()

# Plot the smoothed probability density plot
plt.figure(figsize=(20, 10))
plt.imshow(smooth_normalized_grid_upsampled, extent=[lon_min, lon_max, lat_min, lat_max], origin='lower', cmap='jet', alpha=0.6)
m.drawcoastlines()
m.drawcountries()
m.fillcontinents(color='white', lake_color='aqua')  # Change land color to white

# Draw parallels and meridians with 1-degree intervals, label every 5 degrees
m.drawparallels(parallels, labels=[0, 0, 0, 0], fontsize=10)
m.drawmeridians(meridians, labels=[0, 0, 0, 0], fontsize=10)

# Label every 5 degrees and their multiples
m.drawparallels(np.arange(lat_min, lat_max + 1, 5), labels=[1, 0, 0, 0], fontsize=10)
m.drawmeridians(np.arange(lon_min, lon_max + 1, 5), labels=[0, 0, 0, 1], fontsize=10)

plt.colorbar(label='Probability Density')

plt.xlabel('Longitude')
plt.ylabel('Latitude')
plt.title('Probability Density per Grid Cell at Southern Indian Ocean (Overall Countries)')

plt.tight_layout()
plt.show()